import{_ as n,C as l,c as i,o as d,j as e,a,G as o,a1 as p,w as r}from"./chunks/framework.DDNAyvCW.js";const h="/assets/asr01.Brst6PuI.png",c="/assets/asr02.BhY3z4jf.png",u="/assets/asr03.DiC-DB3I.png",g="/assets/asr04.D1ps4h9W.png",b="/assets/asr05.CkWVRVkh.svg",k="/assets/asr06.BzVJhcCi.png",m="/assets/asr07.CUklXLoy.gif",L=JSON.parse('{"title":"Chaterm 如何使用 ASR + LLM 精准操作 K8S","description":"","frontmatter":{"title":"Chaterm 如何使用 ASR + LLM 精准操作 K8S","author":"DYin","date":"2026-2-6","comment":false,"category":"Technical","tags":["ASR","Kubernetes","LLM","AI","Docker"],"blog":"post","aside":"left","sidebar":false,"prev":false,"next":false},"headers":[],"relativePath":"blog/posts/asr.md","filePath":"blog/posts/asr.md"}'),q={name:"blog/posts/asr.md"};function f(_,t,S,x,E,y){const s=l("font");return d(),i("div",null,[t[3]||(t[3]=e("p",null,"本文介绍 Chaterm 如何通过 ASR 热词表 + LLM 纠错 的双层架构，在移动端实现各种终端操作和 Kubernetes 命令的高精度识别，从而提升移动端的命令输入效率。",-1)),t[4]||(t[4]=e("p",null,"并介绍 Chaterm 提示词工程的设计范式包括：明确的角色定义（Role Definition）、清晰的任务边界约束、结构化的处理流程，以及 Few-shot 示例。来提升模型输出的准确性和一致性。",-1)),t[5]||(t[5]=e("hr",null,null,-1)),t[6]||(t[6]=e("br",null,null,-1)),t[7]||(t[7]=a(" 作为程序员，幸幸苦苦忙碌一年，春节回家也未必轻松，赶火车回家团圆，参加爸妈安排的相亲，同学的婚礼随份子， 被七大姑问候工资，然而最恐怖的却是突如其来的 -- ",-1)),o(s,{style:{color:"red"}},{default:r(()=>t[0]||(t[0]=[a("「[P0 级报警] 核心交易服务响应超时！」",-1)])),_:1,__:[0]}),t[8]||(t[8]=e("p",null,"身为一个程序员，每每看到类似的场景我都感同身受",-1)),t[9]||(t[9]=e("p",null,[e("img",{src:h,alt:""})],-1)),e("p",null,[t[2]||(t[2]=a("为了过个好年，我们打造了一个能够在极端环境下 ",-1)),o(s,{style:{color:"red"}},{default:r(()=>t[1]||(t[1]=[a("单手完成生产系统的救火工具！",-1)])),_:1,__:[1]})]),t[10]||(t[10]=p('<p>然而，碰到的第一个挑战就是，如何让传统的语音识别，能够100%准确的转化成各个云平台API，或者K8S，Linux的操作指令？</p><hr><h2 id="一-k8s-命令语音识别的技术挑战" tabindex="-1">一：K8S 命令语音识别的技术挑战 <a class="header-anchor" href="#一-k8s-命令语音识别的技术挑战" aria-label="Permalink to &quot;一：K8S 命令语音识别的技术挑战&quot;">​</a></h2><h3 id="_1-1-问题背景" tabindex="-1">1.1 问题背景 <a class="header-anchor" href="#_1-1-问题背景" aria-label="Permalink to &quot;1.1 问题背景&quot;">​</a></h3><p>首先要解决的是，工程师经常需要在移动端通过语音快速执行各种命令，各种参数，比如 kubectl 等等。在移动端，这个过程面临一个显著的体验问题：<strong>在手机虚拟键盘上输入复杂的 Kubernetes 命令极其痛苦，而且效率低下</strong>。</p><p><strong>语音输入</strong>是一个自然的解决方案。然而，传统 ASR（Automatic Speech Recognition，自动语音识别）系统在处理 K8S 命令时面临严峻挑战：</p><table tabindex="0"><thead><tr><th>挑战类型</th><th>具体表现</th><th>示例</th></tr></thead><tbody><tr><td><strong>专有名词识别</strong></td><td>命令动词被识别为谐音词</td><td><code>kubectl</code> → &quot;酷 B 控制&quot;、&quot;cube ctl&quot;</td></tr><tr><td><strong>参数组合复杂</strong></td><td>长命令参数丢失或错位</td><td><code>kubectl get pods -n default -o wide</code> → &quot;kubectl get pods default wide&quot;</td></tr><tr><td><strong>资源类型混淆</strong></td><td>缩写与全称混用导致歧义</td><td><code>svc</code> vs <code>services</code>、<code>deploy</code> vs <code>deployments</code></td></tr><tr><td><strong>命名空间参数</strong></td><td>短参数容易被忽略</td><td><code>-n</code>、<code>--namespace</code> 被吞噬或误识别</td></tr><tr><td><strong>特殊字符处理</strong></td><td>符号无法正确识别</td><td><code>-</code>、<code>--</code>、<code>/</code> 等符号丢失</td></tr></tbody></table><h3 id="_1-2-传统方案的局限性" tabindex="-1">1.2 传统方案的局限性 <a class="header-anchor" href="#_1-2-传统方案的局限性" aria-label="Permalink to &quot;1.2 传统方案的局限性&quot;">​</a></h3><p>传统语音识别方案主要存在以下问题：</p><ol><li><strong>通用模型泛化能力不足</strong>：ASR 模型基于海量通用语料训练，对垂直领域专业术语覆盖有限</li><li><strong>OOV（Out-of-Vocabulary）问题</strong>：<code>kubectl</code>、<code>namespace</code>、<code>deployment</code> 等词汇不在常规词表中</li><li><strong>上下文理解缺失</strong>：无法理解命令语义，难以进行智能补全和纠错</li><li><strong>中英文混合识别困难</strong>：K8S 命令涉及大量英文术语与中文口语混合</li></ol><h3 id="_1-3-chaterm-的解决思路" tabindex="-1">1.3 Chaterm 的解决思路 <a class="header-anchor" href="#_1-3-chaterm-的解决思路" aria-label="Permalink to &quot;1.3 Chaterm 的解决思路&quot;">​</a></h3><p><strong>Chaterm 通过双层架构设计，实现了 K8S 命令接近 100% 的精准识别率：</strong></p><hr><p><img src="'+c+'" alt=""></p><hr><h2 id="二、系统架构设计" tabindex="-1">二、系统架构设计 <a class="header-anchor" href="#二、系统架构设计" aria-label="Permalink to &quot;二、系统架构设计&quot;">​</a></h2><h3 id="_2-1-核心组件架构" tabindex="-1">2.1 核心组件架构 <a class="header-anchor" href="#_2-1-核心组件架构" aria-label="Permalink to &quot;2.1 核心组件架构&quot;">​</a></h3><p>在核心组件的实现层面，整体架构遵循「客户端 → 网关 → 外部服务」的设计模式，其中各层级之间通过WebSocket协议进行双向数据交互。</p><p><img src="'+u+'" alt=""></p><p><strong>Flutter 移动端：</strong> 架构分为<strong>用户界面（UI）组件</strong>与<strong>服务层</strong>两大模块。在UI层面，VoiceInputButton 组件为用户提供了一个语音输入的接口，并通过WaveAnimation 实时反馈用户的操作状态；而在服务层面上，AudioStreamService 负责处理PCM格式的音频流采集工作，SpeechService 则封装了基于WebSocket协议的数据传输逻辑，同时，VoiceCommandCorrection 模块封装了精心设计的Prompt，实现了对大型语言模型(LLM)进行调用来完成语音命令的纠正功能。</p><p><strong>网关层：</strong> 采用了Go语言构建后端服务，其核心组成部分包括WebSocket处理器和认证模块。特别地，在建立连接的过程中，会附加一个名为<code>hotword_id</code>的参数，这使得自动语音识别(ASR)系统能够加载相应的热词列表，从而实现“一次握手，全程优化”的效果。</p><p><strong>外部服务体系：</strong> 主要集成了两方面的关键能力：一是利用腾讯云提供的实时语音识别引擎，该引擎支持热词表、替换词、权重增强等音频处理能力；二是集成LLM服务以提供高级别的语义理解和指令生成能力。这两项技术相互配合，共同提升了系统的整体性能。</p><h3 id="_2-2-语音执行执行全流程解析" tabindex="-1">2.2 语音执行执行全流程解析 <a class="header-anchor" href="#_2-2-语音执行执行全流程解析" aria-label="Permalink to &quot;2.2 语音执行执行全流程解析&quot;">​</a></h3><p><img src="'+g+`" alt=""></p><br><p><strong>语音驱动运维指令执行：</strong> 以 kubectl get pods -A 为例</p><p>该流程演示了当用户直接口述技术命令时，系统如何处理识别误差并最终精准执行：</p><p><strong>1. 阶段一：实时语音采集与传输</strong></p><ul><li><strong>指令输入：</strong> 用户在 Flutter 客户端按下按钮，口述指令：“kubectl get pods -A”。</li><li><strong>音频处理：</strong> 客户端 AudioStreamService 实时采集 16khz/16bit 的 PCM 音频帧。</li></ul><p><strong>2. 阶段二：低延迟 ASR 实时反馈</strong></p><ul><li><strong>通信链路：</strong> Flutter 客户端通过 WebSocket 接口（/v1/speech/asr）连接 Go 后端，后端同步建立与腾讯云 ASR 的连接，并携带 hotword_id（热词表）以增强专业术语识别。</li><li><strong>识别挑战：</strong> 由于“kubectl”等词汇在非运维语境下容易被误识别，系统通过挂载运维热词表（hotword_id）来增强准确性。</li><li><strong>实时预览：</strong> ASR 实时返回中间识别结果，由后端推送到客户端，用户可以在界面上看到实时返回的识别文字，例如：“q... q币... cube control...”。</li></ul><p><strong>3. 阶段三：LLM 语义纠错（核心环节）</strong></p><ul><li><strong>原始文本获取：</strong> 语音识别结束，ASR 返回的最终文本可能存在严重偏差，例如：“cube control get pods 杠 a”（将 kubectl 误听为 cube control，将 -A 误听为“杠 a”）。</li><li><strong>调用 LLM：</strong> 调用 VoiceCommandCorrection 接口。</li><li><strong>纠错输出：</strong> LLM 结合运维知识库进行语义分析，将上述混乱的文本精准修正为标准的：kubectl get pods -A。</li></ul><p><strong>4. 阶段四：终端写入与人工确认</strong></p><ul><li><strong>终端写入：</strong> 纠错后的标准指令被发送至输入框。</li><li><strong>最终把关：</strong> 为了安全起见，指令不会立即运行，而是等待用户在客户端二次确认后，才正式在终端环境中触发执行。</li></ul><hr><h2 id="三、第一层-asr-热词表精准识别" tabindex="-1">三、第一层：ASR 热词表精准识别 <a class="header-anchor" href="#三、第一层-asr-热词表精准识别" aria-label="Permalink to &quot;三、第一层：ASR 热词表精准识别&quot;">​</a></h2><h3 id="_3-1-热词表技术原理" tabindex="-1">3.1 热词表技术原理 <a class="header-anchor" href="#_3-1-热词表技术原理" aria-label="Permalink to &quot;3.1 热词表技术原理&quot;">​</a></h3><p><strong>热词表（Hotword List）</strong> 是 ASR 系统提供的一种领域适配机制，通过提升特定词汇在解码过程中的先验概率，显著提高目标词汇的识别准确率。</p><h4 id="_3-1-1-为什么需要热词表" tabindex="-1">3.1.1 为什么需要热词表 <a class="header-anchor" href="#_3-1-1-为什么需要热词表" aria-label="Permalink to &quot;3.1.1 为什么需要热词表&quot;">​</a></h4><p>通用 ASR 模型基于海量日常语料训练，对专业术语覆盖不足，存在 <strong>OOV（Out-of-Vocabulary）问题</strong>。当用户说 &quot;kubectl&quot; 时，模型倾向于输出训练时见过的近音词（如&quot;酷B控制&quot;），而非低频专业术语。</p><h4 id="_3-1-2-工作原理" tabindex="-1">3.1.2 工作原理 <a class="header-anchor" href="#_3-1-2-工作原理" aria-label="Permalink to &quot;3.1.2 工作原理&quot;">​</a></h4><p>ASR 解码时，会计算每个候选词的输出概率。<strong>热词表通过对特定词汇施加概率加成来改变解码结果：</strong></p><div class="language-plain vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plain</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>无热词表：                      有热词表（kubectl 权重100）：</span></span>
<span class="line"><span>─────────────────────          ─────────────────────</span></span>
<span class="line"><span>&quot;酷B控制&quot; P=0.35 ← 选中        &quot;kubectl&quot; P=0.15×5=0.75 ← 选中</span></span>
<span class="line"><span>&quot;kubectl&quot; P=0.15               &quot;酷B控制&quot; P=0.35</span></span></code></pre></div><p>数学表达：<code>P&#39;(热词) = P(热词) × boost_factor</code></p><p>权重越高，boost_factor 越大，热词在同音竞争中获胜概率越高。</p><h4 id="_3-1-3-热词权重设置" tabindex="-1">3.1.3 热词权重设置 <a class="header-anchor" href="#_3-1-3-热词权重设置" aria-label="Permalink to &quot;3.1.3 热词权重设置&quot;">​</a></h4><p>腾讯云 ASR 支持 1-11,100 的权重范围：</p><table tabindex="0"><thead><tr><th>权重范围</th><th>适用场景</th><th>说明</th></tr></thead><tbody><tr><td>1-10</td><td>常规业务词汇</td><td>轻度提升，避免过拟合</td></tr><tr><td>11</td><td>专业术语</td><td>中度提升，平衡准确率与泛化</td></tr><tr><td>100</td><td>核心关键词</td><td>强制识别，适用于 OOV 词汇</td></tr></tbody></table><p><strong>K8S 命令场景采用权重 100</strong>，确保 <code>kubectl</code>、<code>namespace</code> 等核心词汇被优先识别。</p><h3 id="_3-2-k8s-热词表设计" tabindex="-1">3.2 K8S 热词表设计 <a class="header-anchor" href="#_3-2-k8s-热词表设计" aria-label="Permalink to &quot;3.2 K8S 热词表设计&quot;">​</a></h3><p>我们构建了包含 K8S 专用热词表，覆盖以下类别：</p><h4 id="_3-2-1-核心命令动词" tabindex="-1">3.2.1 核心命令动词 <a class="header-anchor" href="#_3-2-1-核心命令动词" aria-label="Permalink to &quot;3.2.1 核心命令动词&quot;">​</a></h4><div class="language-latex vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">latex</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kubectl|100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kubectl get|100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cube control|100</span></span></code></pre></div><h4 id="_3-2-2-资源类型词汇" tabindex="-1">3.2.2 资源类型词汇 <a class="header-anchor" href="#_3-2-2-资源类型词汇" aria-label="Permalink to &quot;3.2.2 资源类型词汇&quot;">​</a></h4><div class="language-latex vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">latex</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pods|100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pod|100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">services|100</span></span></code></pre></div><h4 id="_3-2-3-常用参数组合" tabindex="-1">3.2.3 常用参数组合 <a class="header-anchor" href="#_3-2-3-常用参数组合" aria-label="Permalink to &quot;3.2.3 常用参数组合&quot;">​</a></h4><div class="language-latex vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">latex</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">杠n|100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">杠n default|100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">杠杠 namespace|100</span></span></code></pre></div><h4 id="_3-2-4-完整命令模板" tabindex="-1">3.2.4 完整命令模板 <a class="header-anchor" href="#_3-2-4-完整命令模板" aria-label="Permalink to &quot;3.2.4 完整命令模板&quot;">​</a></h4><div class="language-latex vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">latex</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kubectl get pods|100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kubectl get pods -A|100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kubectl get pods -n default|100</span></span></code></pre></div><h3 id="_3-3-热词表集成流程" tabindex="-1">3.3 热词表集成流程 <a class="header-anchor" href="#_3-3-热词表集成流程" aria-label="Permalink to &quot;3.3 热词表集成流程&quot;">​</a></h3><p><img src="`+b+'" alt=""></p><h2 id="四、第二层-llm-智能纠错" tabindex="-1">四、第二层：LLM 智能纠错 <a class="header-anchor" href="#四、第二层-llm-智能纠错" aria-label="Permalink to &quot;四、第二层：LLM 智能纠错&quot;">​</a></h2><h3 id="_4-1-llm-纠错的必要性" tabindex="-1">4.1 LLM 纠错的必要性 <a class="header-anchor" href="#_4-1-llm-纠错的必要性" aria-label="Permalink to &quot;4.1 LLM 纠错的必要性&quot;">​</a></h3><p>尽管热词表显著提升了专业术语的识别率，但 ASR 输出仍可能存在以下问题：</p><ol><li><strong>残留谐音错误</strong>：部分词汇仍被识别为近音词（如 &quot;kube ctl&quot;）</li><li><strong>自然语言表达</strong>：用户可能说 &quot;查看所有 pod&quot; 而非 &quot;kubectl get pods -A&quot;</li><li><strong>参数顺序混乱</strong>：&quot;-n default&quot; 可能出现在命令中间</li><li><strong>格式不规范</strong>：缺少必要的空格、连字符等</li></ol><p><strong>LLM 层的作用</strong>：作为语义理解层，将 ASR 的原始输出（自然语言、谐音词、不完整命令）转换为<strong>标准的、可执行的 K8S 命令</strong>。</p><h3 id="_4-2-prompt-engineering-设计" tabindex="-1">4.2 Prompt Engineering 设计 <a class="header-anchor" href="#_4-2-prompt-engineering-设计" aria-label="Permalink to &quot;4.2 Prompt Engineering 设计&quot;">​</a></h3><p>业界对**Prompt Engineering（提示词工程）**普遍采用的设计范式包括：明确的角色定义（Role Definition）、清晰的任务边界约束、结构化的处理流程，以及高质量的 <strong>Few-shot 示例</strong>。一个设计良好的 Prompt 能显著提升模型输出的准确性和一致性。</p><p>在 Chaterm 的语音命令纠错场景中，我们遵循上述原则，设计了如下 System Prompt 结构：</p><ul><li><strong>角色定义</strong>：将模型定位为「语音转终端命令助手」，明确其职责边界——只做命令转换，不做额外解释或建议。</li><li><strong>核心原则</strong>：强调保守策略，即「不生造」——不添加用户未提及的参数，避免模型过度推理导致的错误命令。</li><li><strong>处理流程</strong>：分为两个阶段执行，先完成ASR残留的谐音纠错（文本矫正），再进行K8s命令格式规范化（结构补全）。</li><li><strong>纠正规则</strong>：通过不断调试，进一步内置谐音映射表、符号标准化规则、缩写展开规则等领域知识，为模型提供明确的转换依据。</li><li><strong>Few-shot 示例</strong>：覆盖谐音纠错、自然语言转换、参数规范化等典型场景，通过示例引导模型输出符合预期的格式。</li></ul><p><img src="'+k+'" alt=""></p><h3 id="_4-3-llm-纠错效果" tabindex="-1">4.3 LLM 纠错效果 <a class="header-anchor" href="#_4-3-llm-纠错效果" aria-label="Permalink to &quot;4.3 LLM 纠错效果&quot;">​</a></h3><h4 id="典型场景纠错示例" tabindex="-1">典型场景纠错示例 <a class="header-anchor" href="#典型场景纠错示例" aria-label="Permalink to &quot;典型场景纠错示例&quot;">​</a></h4><table tabindex="0"><thead><tr><th>场景</th><th>ASR 原始输出</th><th>LLM 纠错输出</th></tr></thead><tbody><tr><td>谐音纠错</td><td>&quot;酷 B 控制 get 跑的&quot;</td><td>kubectl get pods</td></tr><tr><td>自然语言转换</td><td>&quot;查看所有 pod&quot;</td><td>kubectl get pods -A</td></tr><tr><td>参数规范化</td><td>&quot;kubectl get pods 杠 n default&quot;</td><td>kubectl get pods -n default</td></tr><tr><td>混合纠错</td><td>&quot;kube ctl describe 的 ployment nginx&quot;</td><td>kubectl describe deployment nginx</td></tr><tr><td>资源操作</td><td>&quot;删除 default 下面的 nginx&quot;</td><td>kubectl delete pod nginx -n default</td></tr></tbody></table><hr><h2 id="五、实际案例展示" tabindex="-1">五、实际案例展示 <a class="header-anchor" href="#五、实际案例展示" aria-label="Permalink to &quot;五、实际案例展示&quot;">​</a></h2><h3 id="案例-使用语音输入恢复payment-deployment服务" tabindex="-1">案例 ：使用语音输入恢复payment-deployment服务 <a class="header-anchor" href="#案例-使用语音输入恢复payment-deployment服务" aria-label="Permalink to &quot;案例 ：使用语音输入恢复payment-deployment服务&quot;">​</a></h3><p><img src="'+m+'" alt=""></p><hr><h2 id="六、总结" tabindex="-1">六、总结 <a class="header-anchor" href="#六、总结" aria-label="Permalink to &quot;六、总结&quot;">​</a></h2><p>通过 <strong>ASR与热词增强 + LLM 纠错</strong> 的双层架构，Chaterm 实现了 K8S 命令接近 100% 的精准识别：</p><ol><li><strong>热词表</strong>： K8S 命令热词，权重 增强，确保专有词识别准确率</li><li><strong>LLM 纠错</strong>：将自然语言、同音词、不完整命令转换为标准 K8S 命令</li><li><strong>端到端优化</strong>：从语音输入到命令执行，全链路保障准确率</li><li><strong>未来优化方向</strong>：对短命令、高置信度场景支持跳过 LLM 调用实现本地规则快速修正，根据用户习惯优化热词表进行命令历史学习，支持保存常用命令模板等</li></ol><hr><h2 id="reference" tabindex="-1">Reference <a class="header-anchor" href="#reference" aria-label="Permalink to &quot;Reference&quot;">​</a></h2><ul><li>官网：<a href="https://chaterm.ai/" target="_blank" rel="noreferrer">https://chaterm.ai/</a></li><li>文档：<a href="https://chaterm.ai/docs/" target="_blank" rel="noreferrer">https://chaterm.ai/docs/</a></li><li>Github：<a href="https://github.com/chaterm/Chaterm" target="_blank" rel="noreferrer">https://github.com/chaterm/Chaterm</a></li></ul>',86))])}const v=n(q,[["render",f]]);export{L as __pageData,v as default};
